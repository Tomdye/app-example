{"version":3,"file":"createAction.js","sourceRoot":"","sources":["createAction.ts"],"names":[],"mappings":";;;;;;;;;IAAA,wBAAwC,sBAAsB,CAAC,CAAA;IAC/D,+BAAgD,oCAAoC,CAAC,CAAA;IAGrF,qBAA6B,sBAAsB,CAAC,CAAA;IACpD,wBAAoB,mBAAmB,CAAC,CAAA;IACxC,wBAA6B,WAAW,CAAC,CAAA;IAwEzC;;OAEG;IACH,kBAA2E,KAAU;QACpF,MAAM,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,UAAU,CAAC;IACpE,CAAC;IAFe,gBAAQ,WAEvB,CAAA;IAED;;OAEG;IACH,IAAM,WAAW,GAAG,IAAI,iBAAO,EAA6D,CAAC;IAE7F;;OAEG;IACH,IAAM,YAAY,GAAkB,iBAAO,CAAC;QAC1C,IAAI,IAAI;YACP,MAAM,CAAC,iBAAO,CAAC,IAAI,CAAC,CAAC;QACtB,CAAC;QAED,IAAI,IAAI,CAAC,KAAsB;YAC9B,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACZ,MAAM,IAAI,SAAS,CAAC,iCAA8B,KAAK,OAAG,CAAC,CAAC;YAC7D,CAAC;YACD,IAAM,MAAM,GAA6C,IAAI,CAAC;YAC9D,IAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC;YAChC,EAAE,CAAC,CAAC,WAAW,IAAI,WAAW,KAAK,KAAK,CAAC,CAAC,CAAC;gBAC1C,MAAM,IAAI,SAAS,CAAC,kCAA+B,MAAM,CAAC,IAAI,sBAAkB,CAAC,CAAC;YACnF,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,WAAW,KAAK,KAAK,CAAC,CAAC,CAAC;gBAChC,MAAM,CAAC,CAAC,mBAAmB;YAC5B,CAAC;YACD,MAAM,CAAC,GAAG,CAAC,aAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;QAChC,CAAC;QAED,EAAE,YAAC,OAAwB;YAC1B,IAAM,MAAM,GAA6C,IAAI,CAAC;YAC9D,IAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,IAAI,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBAClC,IAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC1C,MAAM,CAAC,aAAM,CAAC,MAAM,CAAC,GAAG,MAAM,GAAG,cAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACvD,CAAC;YACD,MAAM,CAAC,cAAI,CAAC,OAAO,EAAE,CAAC;QACvB,CAAC;QACD,MAAM;YACL,IAAM,MAAM,GAA6C,IAAI,CAAC;YAC9D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC3B,MAAM,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;YACpC,CAAC;QACF,CAAC;QACD,OAAO;YACN,IAAM,MAAM,GAA6C,IAAI,CAAC;YAC9D,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;YACrC,CAAC;QACF,CAAC;KACD,CAAC;SACD,KAAK,CAAC;QACN,KAAK,EAAE,wBAAc;QACrB,UAAU,YAAC,QAAkD,EAAE,OAA2B;YACzF,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC7B,MAAM,IAAI,SAAS,CAAC,wCAAwC,CAAC,CAAC;YAC/D,CAAC;YACD,WAAW,CAAC,GAAG,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC;YACtC,QAAQ,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,SAAS,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC,CAAC;YAC9E,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB,QAAQ,CAAC,GAAG,CAAC,aAAG,CAAC,QAAQ,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3C,CAAC;YACD,QAAQ,CAAC,GAAG,CAAC;gBACZ,OAAO;oBACN,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAC9B,CAAC;aACD,CAAC,CAAC;QACJ,CAAC;KACD,CAAC,CAAC;IAEJ;sBAAe,YAAY,CAAC","sourcesContent":["import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { Stateful, State } from 'dojo-compose/mixins/createStateful';\nimport { EventObject } from 'dojo-core/interfaces';\nimport { Thenable } from 'dojo-core/Promise';\nimport Task, { isTask } from 'dojo-core/async/Task';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { add, getType } from './actions';\n\nexport interface TargettedEventObject<T> extends EventObject {\n\ttarget: T;\n}\n\nexport interface DoOptions<T> {\n\t[option: string]: any;\n\n\t/**\n\t * The target (subject) of the action\n\t */\n\tevent?: TargettedEventObject<T>;\n}\n\nexport interface ActionState extends State {\n\t/**\n\t * Determines if the action is enabled or not\n\t */\n\tenabled?: boolean;\n}\n\nexport interface Action<T, O extends DoOptions<T>, S extends ActionState> extends Stateful<S> {\n\t/**\n\t * The type of the action, which can be used to reference the action\n\t */\n\ttype: string | symbol;\n\n\t/**\n\t * The main method that performs the action and returns a task which resolves when the action completes\n\t * @param options The options to be passed to the `do` method\n\t */\n\tdo(options?: O): Task<T>;\n\n\t/**\n\t * Enabled the task is disabled\n\t */\n\tenable(): void;\n\n\t/**\n\t * Disable the task if enabled\n\t */\n\tdisable(): void;\n}\n\nexport type DoFunction<T> = (options?: DoOptions<T>) => T | Thenable<T>;\n\nexport interface ActionOptions<T> {\n\t/**\n\t * The method that is invoked when `do()` is called and the action is enabled\n\t */\n\tdo: DoFunction<T>;\n\n\t/**\n\t * Set the enabled state during construction\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * Set the action type during construction\n\t */\n\ttype?: string | symbol;\n}\n\nexport interface ActionFactory extends ComposeFactory<Action<any, DoOptions<any>, ActionState>, ActionOptions<any>> {\n\t/**\n\t * Create a new instance of an Action, using the supplied options\n\t * @param options The options used to construct the Action\n\t */\n\t<T, O extends DoOptions<T>, S extends ActionState>(options: ActionOptions<T>): Action<T, O, S>;\n}\n\n/**\n * A type guard that validates the object passed is an Action\n */\nexport function isAction<T, O extends DoOptions<T>, S extends ActionState>(value: any): value is Action<T, O, S> {\n\treturn typeof value === 'object' && typeof value.do === 'function';\n}\n\n/**\n * A weak map of `do` methods\n */\nconst doFunctions = new WeakMap<Action<any, DoOptions<any>, ActionState>, DoFunction<any>>();\n\n/**\n * A factory which creates instaces of Action\n */\nconst createAction: ActionFactory = compose({\n\t\tget type(): string | symbol {\n\t\t\treturn getType(this);\n\t\t},\n\n\t\tset type(value: string | symbol) {\n\t\t\tif (!value) {\n\t\t\t\tthrow new TypeError(`Cannot set action type to \"${value}\"`);\n\t\t\t}\n\t\t\tconst action: Action<any, DoOptions<any>, ActionState> = this;\n\t\t\tconst currentType = action.type;\n\t\t\tif (currentType && currentType !== value) {\n\t\t\t\tthrow new TypeError(`Action type already set as \"${action.type}\", cannot change`);\n\t\t\t}\n\t\t\telse if (currentType === value) {\n\t\t\t\treturn; /* already added */\n\t\t\t}\n\t\t\taction.own(add(action, value));\n\t\t},\n\n\t\tdo(options?: DoOptions<any>): Task<any> {\n\t\t\tconst action: Action<any, DoOptions<any>, ActionState> = this;\n\t\t\tconst doFn = doFunctions.get(action);\n\t\t\tif (doFn && action.state.enabled) {\n\t\t\t\tconst result = doFn.call(action, options);\n\t\t\t\treturn isTask(result) ? result : Task.resolve(result);\n\t\t\t}\n\t\t\treturn Task.resolve();\n\t\t},\n\t\tenable(): void {\n\t\t\tconst action: Action<any, DoOptions<any>, ActionState> = this;\n\t\t\tif (!action.state.enabled) {\n\t\t\t\taction.setState({ enabled: true });\n\t\t\t}\n\t\t},\n\t\tdisable(): void {\n\t\t\tconst action: Action<any, DoOptions<any>, ActionState> = this;\n\t\t\tif (action.state.enabled) {\n\t\t\t\taction.setState({ enabled: false });\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createStateful,\n\t\tinitialize(instance: Action<any, DoOptions<any>, ActionState>, options: ActionOptions<any>) {\n\t\t\tif (!options || !options.do) {\n\t\t\t\tthrow new TypeError(`'options.do' required during creation.`);\n\t\t\t}\n\t\t\tdoFunctions.set(instance, options.do);\n\t\t\tinstance.setState({ enabled: 'enabled' in options ? options.enabled : true });\n\t\t\tif (options.type) {\n\t\t\t\tinstance.own(add(instance, options.type));\n\t\t\t}\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tdoFunctions.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nexport default createAction;\n"]}