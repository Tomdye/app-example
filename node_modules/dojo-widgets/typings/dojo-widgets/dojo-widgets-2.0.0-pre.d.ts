declare module 'dojo-widgets/mixins/createDestroyable' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	import { Handle } from 'dojo-core/interfaces';
	export interface Destroyable {
	    /**
	     * Take a handle and "own" it, which ensures that its destroy
	     * method is called when the owning object's destroy method is
	     * called.
	     * @param handle The handle to own
	     */
	    own(handle: Handle): Handle;
	    /**
	     * Invoke destroy() on any owned handles
	     */
	    destroy(): Promise<boolean>;
	}
	export function isDestroyable(value: any): value is Destroyable; const createDestroyable: ComposeFactory<Destroyable, any>;
	export default createDestroyable;

}
declare module 'dojo-widgets/mixins/createEvented' {
	import { Handle, EventObject } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	/**
	 * Interface describes evented callbacks
	 */
	export interface EventedCallback<T extends EventObject> {
	    /**
	     * A callback that is called when the event fires
	     * @param event The event object
	     */
	    (event: T): void;
	}
	export interface Actionable<T extends EventObject> {
	    do(options?: {
	        event: T;
	    }): any;
	}
	export type EventedListener<E extends EventObject> = EventedCallback<E> | Actionable<E> | string;
	/**
	 * The options for the events
	 */
	export interface EventedOptions {
	    /**
	     * A map of listeners to attach on initialization
	     */
	    listeners?: {
	        [event: string]: EventedListener<EventObject>;
	    };
	}
	export interface Evented extends Destroyable {
	    /**
	     * Emit an event
	     * @param event The event object to emit
	     */
	    emit<T extends EventObject>(event: T): void;
	    /**
	     * Attach a listener to an event and return a handle that allows the removal of
	     * the listener.
	     * @param type The name of the event
	     */
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface EventedFactory extends ComposeFactory<Evented, EventedOptions> {
	}
	export function resolveEventListener<E extends EventObject>(listener: EventedListener<E>): EventedCallback<E>; const createEvented: EventedFactory;
	export default createEvented;

}
declare module 'dojo-widgets/util/lang' {
	import { List } from 'immutable/immutable';
	export type Position = number | 'first' | 'last' | 'before' | 'after';
	export function insertInList<T>(list: List<T>, item: T, position: Position, reference?: T): List<T>;
	export function insertInArray<T>(array: T[], item: T, position: Position, reference?: T): T[];

}
declare module 'dojo-widgets/mixins/createParentMixin' {
	import { List } from 'immutable/immutable';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Handle } from 'dojo-core/interfaces';
	import { Position } from 'dojo-widgets/util/lang';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	export interface ParentMixinOptions<C extends Child> {
	    children?: C[];
	}
	export interface Child extends Destroyable {
	    parent: ParentMixin<any>;
	}
	export interface ParentMixin<C> extends Destroyable {
	    /**
	     * An immutable list of children for this parent
	     */
	    children?: List<C>;
	    /**
	     * Append a child (or children) to the parent
	     * @param child The child to append
	     */
	    append(child: C): Handle;
	    /**
	     * Append a child (or children) to the parent
	     * @param children The children to append
	     */
	    append(children: C[]): Handle;
	    /**
	     * Insert a child in a specific position, providing the reference if required
	     * @param child The child to insert
	     * @param position The position to insert the child
	     * @param reference The referencable child, if required
	     */
	    insert(child: C, position: Position, reference?: C): Handle;
	}
	export interface ParentMixinFactory<C extends Child> extends ComposeFactory<ParentMixin<C>, ParentMixinOptions<C>> {
	} const createParentMixin: ParentMixinFactory<Child>;
	export default createParentMixin;

}
declare module 'dojo-widgets/mixins/createRenderable' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { VNode } from 'maquette/maquette';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	import { ParentMixin } from 'dojo-widgets/mixins/createParentMixin';
	export interface RenderFunction {
	    (): VNode;
	}
	export interface RenderableOptions {
	    /**
	     * A render function to be used.
	     */
	    render?: RenderFunction;
	    tagName?: string;
	    parent?: ParentMixin<Renderable>;
	}
	export interface Renderable extends Destroyable {
	    /**
	     * Takes no arguments and returns a VNode
	     */
	    render(): VNode;
	    tagName: string;
	    parent: ParentMixin<Renderable>;
	}
	export interface RenderableFactory extends ComposeFactory<Renderable, RenderableOptions> {
	}
	export function isRenderable(value: any): value is Renderable; const createRenderable: RenderableFactory;
	export default createRenderable;

}
declare module 'dojo-widgets/mixins/createStateful' {
	import { Observable } from 'rxjs/Rx';
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	export interface State {
	    [id: string]: any;
	}
	export interface ObservableState<S> {
	    observe(id: string): Observable<S>;
	    patch(partial: any, options?: {
	        id?: string;
	    }): Promise<S>;
	}
	export interface StatefulOptions<S extends State> extends EventedOptions {
	    state?: S;
	    id?: string;
	    stateFrom?: ObservableState<S>;
	}
	export interface StateChangeEvent<S extends State> extends EventObject {
	    type: string;
	    state: S;
	    target: Stateful<S>;
	}
	export interface Stateful<S extends State> extends Evented {
	    /**
	     * A readonly version of the state
	     */
	    state: S;
	    /**
	     * Set the state on the instance.
	     * Set state takes partial values, therefore if a key is omitted, it will not get set.
	     * If you wish to "clear" a value, you should pass it as undefined.
	     * @param value The partial state to be set
	     */
	    setState(value: S): void;
	    /**
	     * Observe the state from an object that allows the observation
	     * @param id         The ID in the target obserable to observe
	     * @param observable The taget that returns an obserable inteface when observing an ID
	     */
	    observeState(id: string, observable: ObservableState<S>): Handle;
	    /**
	     * Add a listener for the event
	     * @param type     The event to listener for
	     * @param listener The event listener
	     */
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {
	    <S extends State>(options?: StatefulOptions<S>): Stateful<S>;
	} const createStateful: StatefulFactory;
	export default createStateful;

}
declare module 'dojo-widgets/mixins/createVNodeEvented' {
	import { Handle, EventObject } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	export interface VNodeListeners {
	    [on: string]: (ev?: EventObject) => boolean | void;
	    ontouchcancel?(ev?: TouchEvent): boolean | void;
	    ontouchend?(ev?: TouchEvent): boolean | void;
	    ontouchmove?(ev?: TouchEvent): boolean | void;
	    ontouchstart?(ev?: TouchEvent): boolean | void;
	    onblur?(ev?: FocusEvent): boolean | void;
	    onchange?(ev?: Event): boolean | void;
	    onclick?(ev?: MouseEvent): boolean | void;
	    ondblclick?(ev?: MouseEvent): boolean | void;
	    onfocus?(ev?: FocusEvent): boolean | void;
	    oninput?(ev?: Event): boolean | void;
	    onkeydown?(ev?: KeyboardEvent): boolean | void;
	    onkeypress?(ev?: KeyboardEvent): boolean | void;
	    onkeyup?(ev?: KeyboardEvent): boolean | void;
	    onload?(ev?: Event): boolean | void;
	    onmousedown?(ev?: MouseEvent): boolean | void;
	    onmouseenter?(ev?: MouseEvent): boolean | void;
	    onmouseleave?(ev?: MouseEvent): boolean | void;
	    onmousemove?(ev?: MouseEvent): boolean | void;
	    onmouseout?(ev?: MouseEvent): boolean | void;
	    onmouseover?(ev?: MouseEvent): boolean | void;
	    onmouseup?(ev?: MouseEvent): boolean | void;
	    onmousewheel?(ev?: MouseWheelEvent): boolean | void;
	    onscroll?(ev?: UIEvent): boolean | void;
	    onsubmit?(ev?: Event): boolean | void;
	}
	export interface VNodeEvented extends Evented {
	    listeners: VNodeListeners;
	    on(type: 'touchcancel', listener: EventedListener<TouchEvent>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, EventedOptions> {
	} const createVNodeEvented: VNodeEventedFactory;
	export default createVNodeEvented;

}
declare module 'dojo-widgets/mixins/createCachedRenderMixin' {
	import { VNode, VNodeProperties } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { EventedListener } from 'dojo-widgets/mixins/createEvented';
	import { ParentMixin } from 'dojo-widgets/mixins/createParentMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	import { State, Stateful, StateChangeEvent, StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	export type StylesHash = {
	    [style: string]: string;
	};
	export interface CachedRenderState extends State {
	    /**
	     * The ID of this widget
	     */
	    id?: string;
	    /**
	     * Any label text for this widget
	     */
	    label?: string;
	    classes?: string[];
	    styles?: StylesHash;
	}
	export interface CachedRenderParent extends ParentMixin<Renderable> {
	    /**
	     * Invalidate the widget so that it will recalculate on its next render
	     */
	    invalidate(): void;
	}
	export interface CachedRenderMixin<S extends CachedRenderState> extends Stateful<S>, Renderable, VNodeEvented {
	    /**
	     * Returns the node attribute properties to be used by a render function
	     * @param overrides Any optional overrides of properties
	     */
	    getNodeAttributes(overrides?: VNodeProperties): VNodeProperties;
	    /**
	     * Returns any children VNodes that are part of the widget
	     */
	    getChildrenNodes(): (VNode | string)[];
	    /**
	     * Invalidate the widget so that it will recalculate on its next render
	     */
	    invalidate(): void;
	    /**
	     * An array of strings that represent classes to be set on the widget.  If classes are present in the state, getting and
	     * setting classes is done on the state, otherwise they are shadowed on the instance.
	     */
	    classes: string[];
	    styles: StylesHash;
	    parent: CachedRenderParent;
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	} const createCachedRenderMixin: ComposeFactory<CachedRenderMixin<CachedRenderState>, StatefulOptions<CachedRenderState>>;
	export default createCachedRenderMixin;

}
declare module 'dojo-widgets/createWidget' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { CachedRenderMixin, CachedRenderState, CachedRenderParent } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	import { Renderable, RenderableOptions } from 'dojo-widgets/mixins/createRenderable';
	import { Stateful, StatefulOptions, StateChangeEvent } from 'dojo-widgets/mixins/createStateful';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	export interface WidgetState extends CachedRenderState {
	}
	export interface WidgetOptions<S extends WidgetState> extends StatefulOptions<S>, EventedOptions, RenderableOptions {
	}
	export interface Widget<S extends WidgetState> extends Stateful<S>, Destroyable, Evented, Renderable, VNodeEvented, CachedRenderMixin<S> {
	    parent: CachedRenderParent;
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface WidgetFactory extends ComposeFactory<Widget<WidgetState>, WidgetOptions<WidgetState>> {
	    <S extends WidgetState>(options?: WidgetOptions<S>): Widget<S>;
	} const createWidget: WidgetFactory;
	export default createWidget;

}
declare module 'dojo-widgets/mixins/createFormFieldMixin' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Stateful, State, StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	export interface FormFieldMixinOptions<V, S extends FormFieldMixinState<V>> extends StatefulOptions<S> {
	    type?: string;
	}
	export interface FormFieldMixinState<V> extends State, CachedRenderState {
	    /**
	     * The form widget's name
	     */
	    name?: string;
	    /**
	     * The current value
	     */
	    value?: V;
	    /**
	     * Whether the field is currently disabled or not
	     */
	    disabled?: boolean;
	}
	export interface FormFieldMixin<V, S extends FormFieldMixinState<V>> extends Stateful<S>, CachedRenderMixin<S> {
	    /**
	     * The HTML type for this widget
	     */
	    type?: string;
	    /**
	     * The string value of this form widget, which is read from the widget state
	     */
	    value?: string;
	}
	export interface FormMixinFactory extends ComposeFactory<FormFieldMixin<any, FormFieldMixinState<any>>, FormFieldMixinState<any>> {
	    <V>(options?: FormFieldMixinOptions<V, FormFieldMixinState<V>>): FormFieldMixin<V, FormFieldMixinState<V>>;
	} const createFormMixin: FormMixinFactory;
	export default createFormMixin;

}
declare module 'dojo-widgets/createButton' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface ButtonState extends WidgetState, FormFieldMixinState<string> {
	}
	export interface ButtonOptions extends WidgetOptions<ButtonState>, FormFieldMixinOptions<any, ButtonState> {
	}
	export interface Button extends Widget<ButtonState>, FormFieldMixin<string, ButtonState> {
	}
	export interface ButtonFactory extends ComposeFactory<Button, ButtonOptions> {
	} const createButton: ButtonFactory;
	export default createButton;

}
declare module 'dojo-widgets/mixins/createContainerMixin' {
	import { List } from 'immutable/immutable';
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Handle } from 'dojo-core/interfaces';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	import { StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	import { Position } from 'dojo-widgets/util/lang';
	export interface ContainerMixinOptions<R extends Renderable, S extends ContainerMixinState> extends StatefulOptions<S> {
	    /**
	     * The children that should be owned by this instance
	     */
	    children?: R[];
	}
	export interface ContainerMixinState extends CachedRenderState {
	}
	export interface ContainerMixin<R extends Renderable, S extends ContainerMixinState> extends CachedRenderMixin<S> {
	    /**
	     * Return an array of VNodes/strings the represent the rendered results of the children of this instance
	     */
	    getChildrenNodes(): (VNode | string)[];
	    /**
	     * Append an renderable item as a child of this instance
	     * @param child The child to append
	     */
	    append(child: Renderable | Renderable[]): Handle;
	    /**
	     * Insert a renderable item as a child of this instance
	     * @param child The child to add
	     * @param position Where the item should be inserted in the children of this instance
	     * @param reference When the posistion is `before` or `after` this is the reference item
	     */
	    insert(child: Renderable, position: Position, reference?: Renderable): Handle;
	    /**
	     * A readonly list of children of this widget
	     */
	    children: List<R>;
	}
	export interface ContainerMixinFactory extends ComposeFactory<ContainerMixin<Renderable, ContainerMixinState>, ContainerMixinOptions<Renderable, ContainerMixinState>> {
	    /**
	     * Create a new instance of a Container
	     * @param options Any options to use during creation
	     */
	    <R extends Renderable>(options?: ContainerMixinOptions<R, ContainerMixinState>): ContainerMixin<R, ContainerMixinState>;
	} const createContainerMixin: ContainerMixinFactory;
	export default createContainerMixin;

}
declare module 'dojo-widgets/createContainer' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ContainerMixin, ContainerMixinState, ContainerMixinOptions } from 'dojo-widgets/mixins/createContainerMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	export interface ContainerState extends WidgetState, ContainerMixinState {
	}
	export interface ContainerOptions extends WidgetOptions<ContainerState>, ContainerMixinOptions<Renderable, ContainerState> {
	}
	export interface Container extends Widget<ContainerState>, ContainerMixin<Renderable, ContainerState> {
	}
	export interface ContainerFactory extends ComposeFactory<Container, ContainerOptions> {
	} const createContainer: ContainerFactory;
	export default createContainer;

}
declare module 'dojo-widgets/createLayoutContainer' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ContainerMixin, ContainerMixinState, ContainerMixinOptions } from 'dojo-widgets/mixins/createContainerMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	export interface LayoutContainerState extends WidgetState, ContainerMixinState {
	}
	export interface LayoutContainerOptions extends WidgetOptions<LayoutContainerState>, ContainerMixinOptions<Renderable, LayoutContainerState> {
	}
	export interface LayoutContainer extends Widget<LayoutContainerState>, ContainerMixin<Renderable, LayoutContainerState> {
	}
	export interface LayoutContainerFactory extends ComposeFactory<LayoutContainer, LayoutContainerOptions> {
	} const createContainer: LayoutContainerFactory;
	export default createContainer;

}
declare module 'dojo-widgets/mixins/createListMixin' {
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	export interface ListStateItem {
	    [property: string]: any;
	    id: string | number;
	    label: string;
	}
	export interface ListMixinState extends CachedRenderState {
	    items?: ListStateItem[];
	}
	export interface TagNames {
	    list: string;
	    item: string;
	}
	export interface ListMixin extends CachedRenderMixin<ListMixinState> {
	    getChildrenNodes(): (VNode | string)[];
	    tagName: string;
	    tagNames: TagNames;
	} const createListMixin: ComposeFactory<ListMixin, StatefulOptions<ListMixinState>>;
	export default createListMixin;

}
declare module 'dojo-widgets/createList' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ListMixin, ListMixinState } from 'dojo-widgets/mixins/createListMixin';
	export interface ListState extends WidgetState, ListMixinState {
	}
	export interface List extends Widget<ListState>, ListMixin {
	}
	export interface ListFactory extends ComposeFactory<List, WidgetOptions<ListState>> {
	} const createList: ListFactory;
	export default createList;

}
declare module 'dojo-widgets/createPanel' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ContainerMixin, ContainerMixinState, ContainerMixinOptions } from 'dojo-widgets/mixins/createContainerMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	export interface PanelState extends WidgetState, ContainerMixinState {
	}
	export interface PanelOptions extends WidgetOptions<PanelState>, ContainerMixinOptions<Renderable, PanelState> {
	}
	export interface Panel extends Widget<PanelState>, ContainerMixin<Renderable, PanelState> {
	}
	export interface PanelFactory extends ComposeFactory<Panel, PanelOptions> {
	} const createPanel: PanelFactory;
	export default createPanel;

}
declare module 'dojo-widgets/projector' {
	import 'dojo-widgets/util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min';
	import { Projector as MaquetteProjector, VNode, VNodeProperties } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Handle } from 'dojo-core/interfaces';
	import { EventedOptions } from 'dojo-widgets/mixins/createEvented';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface ProjectorOptions extends ParentMixinOptions<RenderableChild>, EventedOptions {
	    root?: Element;
	}
	export interface RenderableChild extends Child {
	    render(): VNode;
	}
	export interface Projector extends VNodeEvented, ParentMixin<RenderableChild> {
	    getNodeAttributes(overrides?: VNodeProperties): VNodeProperties;
	    render(): VNode;
	    attach(append?: boolean): Handle;
	    invalidate(): void;
	    setRoot(root: Element): void;
	    projector: MaquetteProjector;
	    tagName?: string;
	    classes?: string[];
	    styles?: {
	        [style: string]: string;
	    };
	    document: Document;
	}
	export interface ProjectorFactory extends ComposeFactory<Projector, ProjectorOptions> {
	}
	export enum ProjectorState {
	    Attached = 0,
	    Detached = 1,
	}
	export const createProjector: ComposeFactory<any, ProjectorOptions & ParentMixinOptions<Child> & EventedOptions>; const defaultProjector: any;
	export default defaultProjector;

}
declare module 'dojo-widgets/createResizePanel' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ContainerMixin, ContainerMixinState, ContainerMixinOptions } from 'dojo-widgets/mixins/createContainerMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	export interface ResizePanelState extends WidgetState, ContainerMixinState {
	    width?: string;
	}
	export interface ResizePanelOptions extends WidgetOptions<ResizePanelState>, ContainerMixinOptions<Renderable, ResizePanelState> {
	}
	export interface ResizePanel extends Widget<ResizePanelState>, ContainerMixin<Renderable, ResizePanelState> {
	    tagNames: {
	        handle: string;
	    };
	    width: string;
	}
	export interface ResizePanelFactory extends ComposeFactory<ResizePanel, ResizePanelOptions> {
	} const createResizePanel: ResizePanelFactory;
	export default createResizePanel;

}
declare module 'dojo-widgets/createTextInput' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface TypedTargetEvent<T extends EventTarget> extends Event {
	    target: T;
	}
	export interface TextInputOptions extends WidgetOptions<FormFieldMixinState<string>>, FormFieldMixinOptions<string, FormFieldMixinState<string>> {
	}
	export interface TextInput extends Widget<FormFieldMixinState<string>>, FormFieldMixin<string, FormFieldMixinState<string>> {
	}
	export interface TextInputFactory extends ComposeFactory<TextInput, TextInputOptions> {
	} const createTextInput: TextInputFactory;
	export default createTextInput;

}
declare module 'dojo-widgets/util/_vdom' {
	import 'dojo-widgets/util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min';
	import { Projector } from 'maquette/maquette';
	import { Handle } from 'dojo-core/interfaces';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	import { Position } from 'dojo-widgets/util/lang';
	/**
	 * The state of the projector
	 */
	export const enum ProjectorState {
	    Attached = 0,
	    Detached = 1,
	}
	/**
	 * Attach a projector to the DOM
	 * @param projector Optional Projector to attach, default one implied
	 */
	export function attach(projector?: Projector): Handle;
	/**
	 * Append a renderable to a projector
	 * @param renderable The renderable object(s) to append, either a Renderable or an array of Renderables
	 * @param projector Optional Projector to append to, default one is implied
	 */
	export function append(renderable: Renderable | Renderable[], projector?: Projector): Handle;
	/**
	 * Insert a renderable into a projector
	 * @param renderable The renderable object to insert
	 * @param position The position where the renderable should be inserted, either an index
	 *                 posistion or a string indicating the relative position
	 * @param reference When using `before` or `after` positions, the renderable to use as
	 *                  reference
	 * @param projector Optional Projector to insert into, default one is implied
	 */
	export function insert(renderable: Renderable, position: Position, reference?: Renderable, projector?: Projector): Handle;
	/**
	 * Clear all the children from a projector
	 * @param projector Optional Projector to attach, default one implied
	 */
	export function clear(projector?: Projector): void;
	/**
	 * Set the root element of a projector
	 * @param root The root element to set on the projector
	 * @param projector An optional projector, default one implied
	 */
	export function setRoot(root: Element, projector?: Projector): void;
	/**
	 * A type guard for Maquette Projectors
	 * @param value The value to type guard against
	 */
	export function isProjector(value: any): value is Projector;
	/**
	 * Schedule a render on a projector
	 * @param projector An optional projector, default one implied
	 */
	export function scheduleRender(projector?: Projector): void;

}
declare module 'dojo-widgets/util/createMemoryStore' {
	import { Observable } from 'rxjs/Rx';
	import Promise from 'dojo-core/Promise';
	import { ComposeFactory } from 'dojo-compose/compose';
	export type StoreIndex = number | string;
	export interface MemoryStorePragma {
	    /**
	     * The identity of the object
	     */
	    id?: StoreIndex;
	    /**
	     * Should the item be replaced if already exists.
	     */
	    replace?: boolean;
	}
	export interface MemoryStorePromise<T> extends Promise<T>, MemoryStore<T> {
	}
	export interface MemoryStoreOptions<T extends Object> {
	    /**
	     * Any initial data that should populate the store
	     */
	    data?: T[];
	    /**
	     * The property of each object to use as the identity for the object
	     */
	    idProperty?: StoreIndex;
	}
	export interface MemoryStore<T extends Object> {
	    /**
	     * The property that determines the ID of the object (defaults to `id`)
	     */
	    idProperty: StoreIndex;
	    /**
	     * Retrieve an object from the store based on the object's ID
	     * @param id The ID of the object to retrieve
	     */
	    get(id: StoreIndex): MemoryStorePromise<T>;
	    /**
	     * Observe an object, any subsequent changes to the object can also be observed via the observable
	     * interface that is returned.  If the object is not present in the store, the observation will be
	     * immediatly completed.  If the object is deleted from the store, the observation will be completed
	     * @param id The ID of the object to observe
	     */
	    observe(id: StoreIndex): Observable<T>;
	    /**
	     * Put an item in the object store.
	     * @param item The item to put
	     * @param options The pragma to use when putting the object
	     */
	    put(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Add an item to the object store.
	     * @param add The item to add
	     * @param options The pragma to use when adding the object
	     */
	    add(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Patch an object in the store by providing a partial object.  The result will be a promise
	     * that resolves with the patched object.
	     * @param partial The partial object to patch the existing object with
	     * @param options The pragma to use when patching the object
	     */
	    patch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Remove an object from the store.
	     * @param id The ID of the object to remove
	     * @param item The object to remove
	     */
	    delete(id: StoreIndex): MemoryStorePromise<boolean>;
	    delete(item: T): MemoryStorePromise<boolean>;
	    /**
	     * Set the stores objects to an array
	     */
	    fromArray(items: T[]): MemoryStorePromise<void>;
	}
	export interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {
	    <T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;
	} const createMemoryStore: MemoryStoreFactory;
	/**
	 * A utility function that takes an array of data and returns a new instance of a MemoryStore
	 * @param data The data used to populate the new store
	 */
	export function fromArray<T>(data: T[]): MemoryStore<T>;
	export default createMemoryStore;

}
declare module 'dojo-widgets/util/has' {
	export * from 'dojo-core/has';

}
declare module 'dojo-widgets/util/query' {
	import { List } from 'immutable/immutable';
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	export interface OrderedQuery<T> extends Query<T> {
	    thenBy(name: string, ascending?: boolean): this;
	}
	export interface Query<T> extends Promise<T> {
	    where(condition: Conditional): this;
	    filter<U>(callback: (item: T, store: any) => boolean): this;
	    select<U>(selection: string[] | ((item: T, store: any) => U)): Query<U>;
	    map<U>(callback: (item: T, store: any) => U): Query<U>;
	    take(): this;
	    skip(): this;
	    orderBy(name: string, ascending?: boolean): OrderedQuery<T>;
	    reverse(): this;
	    sort(callback: (a: T, b: T) => number): this;
	    groupBy<U>(): Query<U>;
	    distinct(): this;
	    union(): this;
	    intersect(): this;
	    except(): this;
	    toArray(): Promise<any[]>;
	    toList(): Promise<List<any>>;
	    construct<T>(factory: ComposeFactory<T, any>): Promise<T[]>;
	    first(): Promise<any>;
	    firstOrDefault(): Promise<any>;
	    elementAt(): Promise<any>;
	    count(): Promise<number>;
	    range(): this;
	    repeat(): this;
	    any(): this;
	    all(): this;
	    count(): Promise<number>;
	    sum(): Promise<number>;
	    min(): Promise<number>;
	    max(): Promise<number>;
	    average(): Promise<number>;
	    aggregate(): Promise<number>;
	    concat(): this;
	    join(): this;
	}
	export interface ConditionalExpression extends Object {
	}
	export interface Conditional {
	    expression: ConditionalExpression;
	}
	export interface ConditionalOperator extends Conditional {
	    and(): Condition;
	    or(): Condition;
	}
	export interface ConditionComparison<T> {
	    matches(condition: RegExp): ConditionalOperator;
	    equals(condition: T): ConditionalOperator;
	    contains(condition: T): ConditionalOperator;
	    lessThan(condition: T): ConditionalOperator;
	    greaterThan(condition: T): ConditionalOperator;
	}
	export interface Condition {
	    property(property: string): ConditionComparison<string>;
	}

}
