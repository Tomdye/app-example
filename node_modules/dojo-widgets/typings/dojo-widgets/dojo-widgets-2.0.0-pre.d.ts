declare module 'dojo-widgets/mixins/createDestroyable' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	import { Handle } from 'dojo-core/interfaces';
	export interface Destroyable {
	    /**
	     * Take a handle and "own" it, which ensures that its destroy
	     * method is called when the owning object's destroy method is
	     * called.
	     * @param handle The handle to own
	     */
	    own(handle: Handle): Handle;
	    /**
	     * Invoke destroy() on any owned handles
	     */
	    destroy(): Promise<boolean>;
	} const createDestroyable: ComposeFactory<Destroyable, any>;
	export default createDestroyable;

}
declare module 'dojo-widgets/mixins/createRenderable' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Projector, VNode } from 'maquette/maquette';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	export interface RenderFunction {
	    (): VNode;
	}
	export interface RenderableOptions {
	    /**
	     * A render function to be used.
	     */
	    render?: RenderFunction;
	    tagName?: string;
	}
	export interface Renderable extends Destroyable {
	    /**
	     * Takes no arguments and returns a VNode
	     */
	    render: RenderFunction;
	    tagName: string;
	    projector: Projector;
	}
	export interface RenderableFactory extends ComposeFactory<Renderable, RenderableOptions> {
	}
	export function isRenderable(value: any): value is Renderable; const createRenderable: RenderableFactory;
	export default createRenderable;

}
declare module 'dojo-widgets/util/vdom' {
	import 'dojo-widgets/util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min';
	import { Projector } from 'maquette/maquette';
	import { Handle } from 'dojo-core/interfaces';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	/**
	 * The state of the projector
	 */
	export const enum ProjectorState {
	    Attached = 0,
	    Detached = 1,
	}
	/**
	 * Attach a projector to the DOM
	 * @param projector Optional Projector to attach, default one implied
	 */
	export function attach(projector?: Projector): Handle;
	/**
	 * Append a renderable to a projector
	 * @param renderable The renderable object to append
	 * @param projector Optional Projector to append to, default one is implied
	 */
	export function append(renderable: Renderable, projector?: Projector): Handle;
	/**
	 * Insert a renderable into a projector
	 * @param renderable The renderable object to insert
	 * @param position The position where the renderable should be inserted, either an index
	 *                 posistion or a string indicating the relative position
	 * @param reference When using `before` or `after` positions, the renderable to use as
	 *                  reference
	 * @param projector Optional Projector to insert into, default one is implied
	 */
	export function insert(renderable: Renderable, position: number | 'first' | 'last' | 'before' | 'after', reference?: Renderable, projector?: Projector): Handle;
	/**
	 * Clear all the children from a projector
	 * @param projector Optional Projector to attach, default one implied
	 */
	export function clear(projector?: Projector): void;
	/**
	 * Set the root element of a projector
	 * @param root The root element to set on the projector
	 * @param projector An optional projector, default one implied
	 */
	export function setRoot(root: Element, projector?: Projector): void;
	/**
	 * Schedule a render on a projector
	 * @param projector An optional projector, default one implied
	 */
	export function scheduleRender(projector?: Projector): void;

}
declare module 'dojo-widgets/mixins/createEvented' {
	import { Handle, EventObject } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	/**
	 * Interface describes evented callbacks
	 */
	export interface EventedCallback<T extends EventObject> {
	    /**
	     * A callback that is called when the event fires
	     * @param event The event object
	     */
	    (event: T): void;
	}
	export interface Actionable<T extends EventObject> {
	    do(options?: {
	        event: T;
	    }): any;
	}
	export type EventedListener<E extends EventObject> = EventedCallback<E> | Actionable<E> | string;
	/**
	 * The options for the events
	 */
	export interface EventedOptions {
	    /**
	     * A map of listeners to attach on initialization
	     */
	    listeners?: {
	        [event: string]: EventedListener<EventObject>;
	    };
	}
	export interface Evented extends Destroyable {
	    /**
	     * Emit an event
	     * @param event The event object to emit
	     */
	    emit<T extends EventObject>(event: T): void;
	    /**
	     * Attach a listener to an event and return a handle that allows the removal of
	     * the listener.
	     * @param type The name of the event
	     */
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface EventedFactory extends ComposeFactory<Evented, EventedOptions> {
	}
	export function resolveEventListener<E extends EventObject>(listener: EventedListener<E>): EventedCallback<E>; const createEvented: EventedFactory;
	export default createEvented;

}
declare module 'dojo-widgets/mixins/createStateful' {
	import { Observable } from 'rxjs/Rx';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	export interface State {
	    [id: string]: any;
	}
	export interface ObservableState<S> {
	    observe(id: string): Observable<S>;
	}
	export interface StatefulOptions<S extends State> extends EventedOptions {
	    state?: S;
	    id?: string;
	    stateFrom?: ObservableState<S>;
	}
	export interface StateChangeEvent<S extends State> extends EventObject {
	    type: string;
	    state: S;
	    target: Stateful<S>;
	}
	export interface Stateful<S extends State> extends Evented {
	    /**
	     * A readonly version of the state
	     */
	    state: S;
	    /**
	     * Set the state on the instance.
	     * Set state takes partial values, therefore if a key is omitted, it will not get set.
	     * If you wish to "clear" a value, you should pass it as undefined.
	     * @param value The partial state to be set
	     */
	    setState(value: S): S;
	    /**
	     * Observe the state from an object that allows the observation
	     * @param id         The ID in the target obserable to observe
	     * @param observable The taget that returns an obserable inteface when observing an ID
	     */
	    observeState(id: string, observable: ObservableState<S>): Handle;
	    /**
	     * Add a listener for the event
	     * @param type     The event to listener for
	     * @param listener The event listener
	     */
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {
	    <S extends State>(options?: StatefulOptions<S>): Stateful<S>;
	} const createStateful: StatefulFactory;
	export default createStateful;

}
declare module 'dojo-widgets/mixins/createVNodeEvented' {
	import { Handle, EventObject } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	export interface VNodeListeners {
	    [on: string]: (ev?: EventObject) => boolean | void;
	    ontouchcancel?(ev?: TouchEvent): boolean | void;
	    ontouchend?(ev?: TouchEvent): boolean | void;
	    ontouchmove?(ev?: TouchEvent): boolean | void;
	    ontouchstart?(ev?: TouchEvent): boolean | void;
	    onblur?(ev?: FocusEvent): boolean | void;
	    onchange?(ev?: Event): boolean | void;
	    onclick?(ev?: MouseEvent): boolean | void;
	    ondblclick?(ev?: MouseEvent): boolean | void;
	    onfocus?(ev?: FocusEvent): boolean | void;
	    oninput?(ev?: Event): boolean | void;
	    onkeydown?(ev?: KeyboardEvent): boolean | void;
	    onkeypress?(ev?: KeyboardEvent): boolean | void;
	    onkeyup?(ev?: KeyboardEvent): boolean | void;
	    onload?(ev?: Event): boolean | void;
	    onmousedown?(ev?: MouseEvent): boolean | void;
	    onmouseenter?(ev?: MouseEvent): boolean | void;
	    onmouseleave?(ev?: MouseEvent): boolean | void;
	    onmousemove?(ev?: MouseEvent): boolean | void;
	    onmouseout?(ev?: MouseEvent): boolean | void;
	    onmouseover?(ev?: MouseEvent): boolean | void;
	    onmouseup?(ev?: MouseEvent): boolean | void;
	    onmousewheel?(ev?: MouseWheelEvent): boolean | void;
	    onscroll?(ev?: UIEvent): boolean | void;
	    onsubmit?(ev?: Event): boolean | void;
	}
	export interface VNodeEvented extends Evented {
	    listeners: VNodeListeners;
	    on(type: 'touchcancel', listener: EventedListener<TouchEvent>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, EventedOptions> {
	} const createVNodeEvented: VNodeEventedFactory;
	export default createVNodeEvented;

}
declare module 'dojo-widgets/mixins/createCachedRenderMixin' {
	import { VNode, VNodeProperties } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { State, Stateful, StateChangeEvent, StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	import { EventedListener } from 'dojo-widgets/mixins/createEvented';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	export interface CachedRenderState extends State {
	    /**
	     * The ID of this widget
	     */
	    id?: string;
	    /**
	     * Any label text for this widget
	     */
	    label?: string;
	}
	export interface CachedRenderMixin<S extends CachedRenderState> extends Stateful<S>, Renderable, VNodeEvented {
	    /**
	     * Returns the node attribute properties to be used by a render function
	     * @param overrides Any optional overrides of properties
	     */
	    getNodeAttributes(overrides?: VNodeProperties): VNodeProperties;
	    /**
	     * Returns any children VNodes that are part of the widget
	     */
	    getChildrenNodes(): VNode[];
	    /**
	     * Invalidate the widget so that it will recalculate on its next render
	     */
	    invalidate(): void;
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	} const createCachedRenderMixin: ComposeFactory<CachedRenderMixin<CachedRenderState>, StatefulOptions<CachedRenderState>>;
	export default createCachedRenderMixin;

}
declare module 'dojo-widgets/createWidget' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { Destroyable } from 'dojo-widgets/mixins/createDestroyable';
	import { Evented, EventedOptions, EventedListener } from 'dojo-widgets/mixins/createEvented';
	import { Renderable, RenderableOptions } from 'dojo-widgets/mixins/createRenderable';
	import { Stateful, StatefulOptions, StateChangeEvent } from 'dojo-widgets/mixins/createStateful';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	export interface WidgetState extends CachedRenderState {
	}
	export interface WidgetOptions<S extends WidgetState> extends StatefulOptions<S>, EventedOptions, RenderableOptions {
	}
	export interface Widget<S extends WidgetState> extends Stateful<S>, Destroyable, Evented, Renderable, VNodeEvented, CachedRenderMixin<S> {
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<EventObject>): Handle;
	}
	export interface WidgetFactory extends ComposeFactory<Widget<WidgetState>, WidgetOptions<WidgetState>> {
	    <S extends WidgetState>(options?: WidgetOptions<S>): Widget<S>;
	} const createWidget: WidgetFactory;
	export default createWidget;

}
declare module 'dojo-widgets/mixins/createFormFieldMixin' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Stateful, State, StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	import { CachedRenderMixin } from 'dojo-widgets/mixins/createCachedRenderMixin';
	export interface FormFieldMixinOptions {
	    type?: string;
	}
	export interface FormFieldMixinState<V> extends State {
	    /**
	     * The form widget's name
	     */
	    name?: string;
	    /**
	     * The current value
	     */
	    value?: V;
	    /**
	     * Whether the field is currently disabled or not
	     */
	    disabled?: boolean;
	}
	export interface FormFieldMixin<V, S extends FormFieldMixinState<V>> extends Stateful<S>, CachedRenderMixin<S> {
	    /**
	     * The HTML type for this widget
	     */
	    type?: string;
	    /**
	     * The string value of this form widget, which is read from the widget state
	     */
	    value?: string;
	}
	export interface FormMixinFactory extends ComposeFactory<FormFieldMixin<any, FormFieldMixinState<any>>, FormFieldMixinOptions> {
	    <V>(options?: StatefulOptions<FormFieldMixinState<V>>): FormFieldMixin<V, FormFieldMixinState<V>>;
	} const createFormMixin: FormMixinFactory;
	export default createFormMixin;

}
declare module 'dojo-widgets/createButton' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface ButtonState extends WidgetState, FormFieldMixinState<string> {
	}
	export interface ButtonOptions extends WidgetOptions<ButtonState>, FormFieldMixinOptions {
	}
	export interface Button extends Widget<ButtonState>, FormFieldMixin<string, ButtonState> {
	}
	export interface ButtonFactory extends ComposeFactory<Button, ButtonOptions> {
	} const createButton: ButtonFactory;
	export default createButton;

}
declare module 'dojo-widgets/mixins/createListMixin' {
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { StatefulOptions } from 'dojo-widgets/mixins/createStateful';
	export interface ListStateItem {
	    [property: string]: any;
	    id: string | number;
	    label: string;
	}
	export interface ListMixinState extends CachedRenderState {
	    items?: ListStateItem[];
	}
	export interface TagNames {
	    list: string;
	    item: string;
	}
	export interface ListMixin extends CachedRenderMixin<ListMixinState> {
	    getChildrenNodes(): VNode[];
	    tagName: string;
	    tagNames: TagNames;
	} const createListMixin: ComposeFactory<ListMixin, StatefulOptions<ListMixinState>>;
	export default createListMixin;

}
declare module 'dojo-widgets/createList' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ListMixin, ListMixinState } from 'dojo-widgets/mixins/createListMixin';
	export interface ListState extends WidgetState, ListMixinState {
	}
	export interface List extends Widget<ListState>, ListMixin {
	}
	export interface ListFactory extends ComposeFactory<List, WidgetOptions<ListState>> {
	} const createList: ListFactory;
	export default createList;

}
declare module 'dojo-widgets/createTextInput' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface TypedTargetEvent<T extends EventTarget> extends Event {
	    target: T;
	}
	export interface TextInputOptions extends WidgetOptions<FormFieldMixinState<string>>, FormFieldMixinOptions {
	}
	export interface TextInput extends Widget<FormFieldMixinState<string>>, FormFieldMixin<string, FormFieldMixinState<string>> {
	}
	export interface TextInputFactory extends ComposeFactory<TextInput, TextInputOptions> {
	} const createTextInput: TextInputFactory;
	export default createTextInput;

}
declare module 'dojo-widgets/util/createMemoryStore' {
	import { Observable } from 'rxjs/Rx';
	import Promise from 'dojo-core/Promise';
	import { ComposeFactory } from 'dojo-compose/compose';
	export type StoreIndex = number | string;
	export interface MemoryStorePragma {
	    id?: StoreIndex;
	    replace?: boolean;
	}
	export interface MemoryStorePromise<T> extends Promise<T>, MemoryStore<T> {
	}
	export interface MemoryStoreOptions<T extends Object> {
	    data?: T[];
	    idProperty?: string | symbol;
	}
	export interface MemoryStore<T extends Object> {
	    /**
	     * The property that determines the ID of the object (defaults to `id`)
	     */
	    idProperty: string | symbol;
	    /**
	     * Retrieve an object from the store based on the object's ID
	     * @param id The ID of the object to retrieve
	     */
	    get(id: StoreIndex): MemoryStorePromise<T>;
	    /**
	     * Observe an object, any subsequent changes to the object can also be observed via the observable
	     * interface that is returned.  If the object is not present in the store, the observation will be
	     * immediatly completed.  If the object is deleted from the store, the observation will be completed
	     * @param id The ID of the object to observe
	     */
	    observe(id: StoreIndex): Observable<T>;
	    /**
	     * Put an item in the object store.
	     * @param item The item to put
	     * @param options The pragma to use when putting the object
	     */
	    put(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Add an item to the object store.
	     * @param add The item to add
	     * @param options The pragma to use when adding the object
	     */
	    add(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     *
	     */
	    patch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Remove an object from the store.
	     * @param id The ID of the object to remove
	     * @param item The object to remove
	     */
	    delete(id: StoreIndex): MemoryStorePromise<boolean>;
	    delete(item: T): MemoryStorePromise<boolean>;
	    /**
	     * Set the stores objects to an array
	     */
	    fromArray(items: T[]): MemoryStorePromise<void>;
	}
	export interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {
	    <T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;
	} const createMemoryStore: MemoryStoreFactory;
	export function fromArray(data: any[]): MemoryStore<any>;
	export default createMemoryStore;

}
declare module 'dojo-widgets/util/has' {
	export * from 'dojo-core/has';
	import has from 'dojo-core/has';
	export function load(resourceId: string, require: DojoLoader.Require, load: (value?: any) => void, config?: Object): void;
	export function normalize(moduleId: string, normalize: (moduleId: string) => string): string;
	export default has;

}
declare module 'dojo-widgets/util/query' {
	import { List } from 'immutable/immutable';
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	export interface OrderedQuery<T> extends Query<T> {
	    thenBy(name: string, ascending?: boolean): this;
	}
	export interface Query<T> extends Promise<T> {
	    where(condition: Conditional): this;
	    filter<U>(callback: (item: T, store: any) => boolean): this;
	    select<U>(selection: string[] | ((item: T, store: any) => U)): Query<U>;
	    map<U>(callback: (item: T, store: any) => U): Query<U>;
	    take(): this;
	    skip(): this;
	    orderBy(name: string, ascending?: boolean): OrderedQuery<T>;
	    reverse(): this;
	    sort(callback: (a: T, b: T) => number): this;
	    groupBy<U>(): Query<U>;
	    distinct(): this;
	    union(): this;
	    intersect(): this;
	    except(): this;
	    toArray(): Promise<any[]>;
	    toList(): Promise<List<any>>;
	    construct<T>(factory: ComposeFactory<T, any>): Promise<T[]>;
	    first(): Promise<any>;
	    firstOrDefault(): Promise<any>;
	    elementAt(): Promise<any>;
	    count(): Promise<number>;
	    range(): this;
	    repeat(): this;
	    any(): this;
	    all(): this;
	    count(): Promise<number>;
	    sum(): Promise<number>;
	    min(): Promise<number>;
	    max(): Promise<number>;
	    average(): Promise<number>;
	    aggregate(): Promise<number>;
	    concat(): this;
	    join(): this;
	}
	export interface ConditionalExpression extends Object {
	}
	export interface Conditional {
	    expression: ConditionalExpression;
	}
	export interface ConditionalOperator extends Conditional {
	    and(): Condition;
	    or(): Condition;
	}
	export interface ConditionComparison<T> {
	    matches(condition: RegExp): ConditionalOperator;
	    equals(condition: T): ConditionalOperator;
	    contains(condition: T): ConditionalOperator;
	    lessThan(condition: T): ConditionalOperator;
	    greaterThan(condition: T): ConditionalOperator;
	}
	export interface Condition {
	    property(property: string): ConditionComparison<string>;
	}

}
