(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", './util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min', 'maquette/maquette', 'dojo-compose/compose', 'dojo-core/global', 'dojo-core/lang', 'dojo-core/queue', 'dojo-core/WeakMap', './mixins/createVNodeEvented', './mixins/createParentMixin'], factory);
    }
})(function (require, exports) {
    "use strict";
    require('./util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min'); /* IE9/Node do not support RequestAnimationFrame */
    var maquette_1 = require('maquette/maquette');
    var compose_1 = require('dojo-compose/compose');
    var global_1 = require('dojo-core/global');
    var lang_1 = require('dojo-core/lang');
    var queue_1 = require('dojo-core/queue');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var createVNodeEvented_1 = require('./mixins/createVNodeEvented');
    var createParentMixin_1 = require('./mixins/createParentMixin');
    /* maquette polyfills changed from 2.2 to 2.3 */
    global_1.default.requestAnimationFrame = global_1.default.requestAnimationFrame || global_1.default.window.requestAnimationFrame;
    (function (ProjectorState) {
        ProjectorState[ProjectorState["Attached"] = 0] = "Attached";
        ProjectorState[ProjectorState["Detached"] = 1] = "Detached";
    })(exports.ProjectorState || (exports.ProjectorState = {}));
    var ProjectorState = exports.ProjectorState;
    ;
    var projectorDataMap = new WeakMap_1.default();
    var noopHandle = { destroy: function () { } };
    function detach(projectorData) {
        projectorData.attachHandle = noopHandle;
        projectorData.projector.detach(projectorData.boundRender);
    }
    exports.createProjector = compose_1.default({
        getNodeAttributes: function (overrides) {
            /* TODO: This is the same logic as createCachedRenderMixin, merge somehow */
            var projector = this;
            var props = {};
            for (var key in projector.listeners) {
                props[key] = projector.listeners[key];
            }
            var classes = {};
            if (projector.classes) {
                projector.classes.forEach(function (c) { return classes[c] = true; });
            }
            props.classes = classes;
            props.styles = projector.styles || {};
            if (overrides) {
                lang_1.assign(props, overrides);
            }
            return props;
        },
        render: function () {
            var projector = this;
            var childVNodes = [];
            projector.children.forEach(function (child) { return childVNodes.push(child.render()); });
            return maquette_1.h(projector.tagName || 'div', projector.getNodeAttributes(), childVNodes);
        },
        attach: function (append) {
            var projector = this;
            var projectorData = projectorDataMap.get(projector);
            if (projectorData.state === ProjectorState.Attached) {
                return projectorData.attachHandle;
            }
            projectorData.boundRender = projector.render.bind(projector);
            /* attaching async, in order to help ensure that if there are any other async behaviours scheduled at the end of the
             * turn, they are executed before this, since the attachement is actually done in turn, but subsequent schedule
             * renders are done out of turn */
            queue_1.queueTask(function () {
                (append ? projectorData.projector.append : projectorData.projector.merge)(projectorData.root, projectorData.boundRender);
            });
            projectorData.state = ProjectorState.Attached;
            return projector.own({
                destroy: function () {
                    detach(projectorData);
                }
            });
        },
        invalidate: function () {
            var projectorData = projectorDataMap.get(this);
            if (projectorData.state === ProjectorState.Attached) {
                projectorData.projector.scheduleRender();
            }
        },
        setRoot: function (root) {
            var projectorData = projectorDataMap.get(this);
            if (projectorData.state === ProjectorState.Attached) {
                throw new Error('Projector already attached, cannot change root element');
            }
            projectorData.root === root;
        },
        get projector() {
            return projectorDataMap.get(this).projector;
        },
        get document() {
            var projectorData = projectorDataMap.get(this);
            return projectorData && projectorData.root && projectorData.root.ownerDocument;
        }
    })
        .mixin({
        mixin: createParentMixin_1.default,
        initialize: function (instance, options) {
            var projector = maquette_1.createProjector({});
            var root = options && options.root || document.body;
            projectorDataMap.set(instance, {
                projector: projector,
                root: root,
                state: ProjectorState.Detached
            });
        }
    })
        .mixin({
        mixin: createVNodeEvented_1.default,
        initialize: function (instance) {
            instance.on('mousemove', function () { });
            instance.on('mouseup', function () { });
        }
    });
    var defaultProjector = exports.createProjector();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = defaultProjector;
});
//# sourceMappingURL=_debug/projector.js.map